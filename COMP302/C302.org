#+OPTIONS: ^:nil 
* Lecture 1 <2017-09-12 Tue>
This course is an introduction to the foundations and paradigms of programming languages.
- 5 assignments, 5% each
- 10% midterm
- 65% final
- You have two late days for the semester (cumulative)
** Four main goals of COMP 302
1. Provide thorough introduction to fundamental concepts in programming languages
   - Higher-order functions
   - State-full vs state-free computation (most languages like Java we've seen are state-full)
   - Modeling objects and closures
   - Exceptions to defer control
   - Continuations to defer control
   - Polymorphism
   - Partial evaluation
   - Lazy programming
   - Modules
   - Etc.
   - Want to explore these concepts so you can recognize them in another language you study at some point
2. Show different ways to reason about programs
   - Type checking
     - One of the best inventions
     - Checks what it expects and will actually tell you where it expects something
     - Program is more likely to be correct now
   - Induction
     - Proving a program/transformation correct
   - Operational semantics
     - How a program is executed
   - QuickCheck
3. Introduce fundamental principles in programming language design
   - Grammars
   - Parsing
   - Operational semantics and interpreters
   - Type checking
   - Polymorphism
   - Subtyping
4. Expose students to a different way of thinking about problems
   - It's like going to the gym; it's good for you!
*** How we achieve these goals
- Functional programming in OCaml
  - Equal playing field
    - No one in the class really knows it, not affected by performance in previous classes like 250
  - Allows us to explain and model object-oriented and imperative programming
    - Isolates lots of the concepts individually
  - Isolates concepts such as state-full vs state-free, modules and functions, etc.
  - Statically typed language enforces disciplined programming
    - Also demonstrates that types are an important maintenance tool
  - Easy to reason about runtime behavior and cost
*** Guiding Principles
- No point in learning a programming language unless it changes how you view programming
- Simple and elegant solutions are more effective, but harder to find than the complicated ones, take more time.
  - You spend very little time testing OCaml code and more time compiling it

*** Why do I need to know this
- Science and craft of programming
- Skills you learn will help you become a better programmer
  - More productive
  - Code easier to maintain and read
  - Etc.
- Will be needed in some upper level courses
  - Like compilers, etc.
- It is cool and fun!
- You might even get a job!

** Assignments
- Can do assignments in groups of 2

** Misc
- Lectures won't be recorded.
- Slides may or may not be posted, but there are lecture notes on MyCourses (most essential reading)
* Lecture 2 <2017-09-14 Thu>
** What is OCaml
- Statically typed functional programming language
*** Statically typed
  - Types approximate runtime behavior
  - Analyze programs before executing them
  - Find a fix bugs before testing
  - Tries to rule out bad scenarios
  - Very efficient, very good error messages, very good maintenance tool
*** Functional
  - Primary expressions are functions!
  - Functions are first-class!
    - Not only can we return base types like ints, we can return functions and pass them as arguments too
    - One of the key features of functional languages
  - Pure vs Not Pure languages
    - Haskell is Pure
      - Doesn't give you ways to allocate memory or directly modify memory
    - OCaml is impure
      - Has arrays and consequences and stuff
  - Call-By-Value vs Lazy
    - OCaml is call by value
*** Concepts for Today
- Writing and executing basic expressions
- Learn how to read error messages
- Names
*** OCaml demo in class
- Always have to finish a line with 2 semi colons ;;
- Can use interpreter by launching OCaml in shell
- Functional good for parallel computing
- Good to reason about these programs
- int: 
  - 1 ;;
  - 1+3;;
- Strings: 
  - "Hello";;
- Floats:
  - 3.14;;
- Booleans:
  - true;;
- if
  - if 0=0 then 1.4 else 2.1 ;;
**** Operators
- +, -, /, *
  - Take as input 2 int, return int
- 3.14 + 1 ;; \to error
- To specify for floating point operators, follow by a dot. Only works with floating points, no ints
  - 3.14 +. 2.4 ;;
**** Types
- Approximate the runtime behaviour
- Types classify expressions according to the value they will compute
- Won't execute right away, will think of types you are returning to see if it's valid
- if 0=0 then 1.4 else 3 ;; 
  - Error, after reading 1.4 expects 3 to be float
- if bool then T else T
  - Both Ts have to be the same type
- Type checker will allow 1/0;; to run, but will have a runtime exception
  - int/int is not enough info to know that your dividing by 0
**** Vars 
- let pi = 3.14 ;;
- let (pi : float) = 3.14 ;;
- let m = 3 in
  - let n=m * m in
  - let k=m*m in
  - k*n ;;
**** Binding 
- let m = 3 ;; puts it on the stack
- let m = 3 in ...
  - m is a local variable now (temporary binding), once you hit ;;, won't have m anymore
  - Garbage collector
- let x (name of a variable) = exp in _exp_ (x is bound to this expression)
- variables are bind to values, not assigned values
  - they look in the past!

**** Functions
- let area = function r -> pi *. r * .r;;
  - Syntax error
- let area = function r -> pi *. r *. r ;;
- let area r = pi *. r *. r ;;
- let a4 = area (2.0);;
- If you redefine pi, like let pi = 6.0 ;;
- area(2.0) will still give you the same thing
- The function looks up in the past

- Stack: 
|      |                           |
|------+---------------------------|
| pi   |                       6.0 |
| area | function r -> p *. r *. r |
| k    |                         5 |
| k    |                         4 |
| pi   | 3.14                      |

- Can redefine the function though
* Lecture 3 <2017-09-15 Fri>
** Functions
- Functions are values
- Function names establish a binding of the function name to its body
  - let area (r:float)=pi*. r *. r ;;
*** Recursive functions
Recursive functions are declared using the keyword _let rec_
- let rec fact n =
  - if m = 0 them 1
    - else n*face(n-1)
- fact 2 needs to be stored on the stack
- fact 2 -> 2* fact 1
- fact 1 -> 1* fact 0 stored on stack
- fact 0 = 1
- Need to remember computation when you come back out of recursion, so need to store on the stack
  - What's the solution to this? How is functional programming efficient?
**** Tail-recursive functions
  A function is said to be "tail-recursive", if there is nothing to do except return the final value. Since the execution of the function is done, saving its stack frame (i.e. where we remember the work we still in general need to do), is redundant
  - Write efficient code
  - All recursive functions can be translated into tail-recursive form
**** Ex. Rewrite Factorial
- let rec fact_tr n =
  - let rec f(n,m) -
    - if n=0 then
      - m
    - else f(n-1,n*m)
  - in
    - f(n,1)

- Second parameter to accumulate the results in the base case we simply return its result

- Avoids having to return a value from the recursive call and subsequently doing further computation

- Avoids building up a runtime stack to memorize what needs to be done once the recursive call returns a value

- f(2,1) -> fact(1, 2*1) -> fact(0,2)-> 2

- Whoever uses the function does not need to know how the function works, so you can use this more efficient way in the background

- What is the type of fact_tr? fact_tr: int(input) $\to$ int(output)

- Type of f? f: int * int (tuple input) $\to$ int

  - n-tuples don't need to be of the same type, can have 3 different types, like int*bool*string
*** Passing arguments
- ' means any type, i.e. 'a
- All args at same time
  - 'a*'b -> 'c
- One argument at a time
  - 'a -> 'b -> 'c
  - May not have a and b at the same time. Once it has both it will get c.
- We can translate any function from one to the other type, called currying (going all at once to one at a time) and uncurrying (opposite).
  - Will see in 2 weeks
** Data Types and Pattern Matching
*** Playing cards
- How can we model a collection of cards?
- Declare a new type together with its elements
- type suit = Clubs | Spades | Hearts | Diamonds
  - Called a user-defined (non-recursive) data type
  - Order of declaration does not matter
    - Like a set
  - We call clubs, spades, hearts, diamonds constructors (or constants), also called elements of this type
    - _Constructors_ must begin with a _capital letter_ in OCaml
- Use _pattern matching_ to analyze elements of a given type.
- match <expression> with
  | <pattern> -> <expression> 
  | <pattern> -> <expression> 
  ...
  | <pattern> -> <expression> 
A pattern is either a variable or a ...
- Statements checked in order
**** Comparing suits
Write a function dom of type suit*suit -> bool
- dom(s1,s2) = true iff suit s1 beats or is equal to suit s2 relative to the ordering Spades > Hearts > Diamonds > Clubs
- (Spades, _) means Spades and anything
- (s1, s2) -> s1=s2 will return the result of s1=s2
- Compiler gives you warning if it's not exhaustive and tells you some that aren't matched
* Lecture 4 <2017-09-19 Tue>
** Data Types and Pattern Matching Continued
- Type is unordered
- type suit = Clubs | Spades | Hearts | Diamonds
  - Order doesn't matter here, but they must start with capitals
- type rank = Two | Three | ...
- type card = rank * suit
What is a hand? A hand is either empty or if c is a card and h is a hand then Hand(c,h). Nothing else is a hand. Hand is a constructor. hand is a type. (capitalization mattersA)
- Recursive user defined data type
- Inductive or recursive definition of a hand
  - Add a card to something that is a hand, still a hand
*** Recursive data type
- type hand = Empty | Hand of card * hand
**** Typing into interpreter
- Empty;;
  - hand = Empty
- let h1 = Hand ((Ace, Spades),Empty);;
  - Want only 1 card, so include empty
  - Recursive data type, so it needs another hand in it
- let h2 = Hand ((Queen, Hearts), Hand((Ace,Spades), Empty);;
  - Recursive
- let h3 = Hand ((Joker, Hearts), h2) ;;
  - Error, Joker not defined
- type 'a list = Nil | Cons of 'a * 'a list
- Hand ((Queen, Hearts), (King, Spades), (Three, Diamonds));;
  - Hand has type? card * card * card
  - Get an error, because constructor Hand expects 2 arguments (card+hand)
*** Extract Example
- Given a hand, extract all cards of a certain suit
- extract: suit -> hand -> hand
# - let rec extract (s:suit) (h:hand) = raise Not_Implemented
  
#+BEGIN_SRC ocaml
let rec extract (s:suit) (h:hand) = match h with
  | Empty -> Empty (* We are constructing results, not destructing given hand *)
  (* Want to extract suit from first card *)
  | Hand ( (r0.s0) ,h) -> 
     (*Make a hand with first card and remaining results of recursive ext*)
     if s0 = s then Hand( (r0, s0), extract s h0)
     else extract s h0
#+END_SRC
Hand is "destroyed" through this method, but old hand stays the same, it is not modified.
- Running extract Spades hand5;; will give a new hand with only spades
- Good exercise, write a function that counts how many cards in the hand
- Can we make this thing tail recursive?

#+BEGIN_SRC ocaml
let rec extract' (s:suit) (h:hand) acc = match h with
  | Empty -> acc (* Accumulator *)
  (* Want to extract suit from first card *)
  | Hand ( (r0.s0) ,h) -> 
     (*Make a hand with first card and remaining results of recursive ext*)
     if s0 = s then extract' s h0 (Hand( (r0, s0), acc))
     else extract' s h0 acc
#+END_SRC

- extract' Spades hand5 Empty ;;
- Gives same cards but in the reverse order of extract
- extract Spades hand5 = extract' Spades hand5 Empty ;;
  - False

- Write a function find which when given a rank and a hand, finds the first card in hand of the specified rank and returns its corresponding suit.
What if no card exists?
- Optional Data Type (predefined)
- type 'a option = None | Some of 'a
* Lecture 5 <2017-09-21 Thu>
#+INCLUDE: "Test/5.ml" src ocaml
** Lists
What are lists?
- Nil([]) is a list
- Given an element x and a list l x::l is a list
- Nothing else is a list
- [] is an $'\alpha$ list
  - Given an element x of type $'\alpha$ and l of type $'\alpha$ list
  - x :: l is an $'\alpha$ list (i.e. a list containing elements of type $'\alpha$)
- ; are syntactical sugar to separate elements of a list
** Execution
Understand how a program is executed
- *Operational Semantics*
* Lecture 6 <2017-09-22 Fri>
** Proofs
*** Demo: lookup & insert
#+INCLUDE: "Test/6.ml" src ocaml
- What is the relationship between lookup and insert?
*** How to prove it?
**** Step 1
We need to understand how programs are executed (operational semantics)
   - $e \Downarrow v$ expression $e$ evaluates in multiple steps to the value $v$. (*Big-Step*)
   - $e \Rightarrow e'$ expression $ee$ evaluates in one steps to expression $e'$. (*Small-Step (single)*)
   - $e \implies^* e'$ expression $e$ evaluates in multiple steps to expression $e'$ (*Small-Step (multiple)*)

For all l, v, k, lookup k (insert k v l) $\implies *$ Some v
Induction on what?
**** Step 2
$P(l) = lookup k$ (insert$(k,v) l$) $\Downarrow$ Some $v$
- How to reason inductively about lists?
   - Analyze their structure!
   - The recipe ...
   - To prove a property $P(l)$ holds about a list $l$
     - Base Case: $l = []$
       - Show $P([])$ holds
     - Step Case: $l=x::xs$
       - IH $P(xs)$ (Assume the property $P$ holds for lists smaller than $l$)
     - Show $P(x::xs)$ holds (Show the property $P$ holds for the original list $l$)
**** Theorem
For all $l, v, k$, lookup $k$ (insert $(k,v) l$) $\implies *$ Some $v$
**** Proof
Proof by structural inductional on the list $l$
- Case: $l = []$
  - lookup k (insert(k,v)[])
  - $\stackrel{\text{By insert program}}{\implies}$ lookup k [(k,v)] (same as (k,v)::[]) $\stackrel{\text{By lookup}}{\implies}$ Some $v$
    - Would not hold if we didn't put the k=k case
- Case: $l=h::t$ where $h=(k',v')$
  - IH: For $k,v$ lookup $k$ (insert (k,v) t) $\Downarrow$ Some $v$
  - To show: lookup k (insert (k,v)) $\underbrace{(k',v')::t}_l \Downarrow$ Some $v$
  - Subcase: $k=k'$
    - lookup k (insert (k,v) ((k', v')::t))
    - $\stackrel{\text{By insert}}{\implies}$ lookup k ((k,v)::t)
    - $\stackrel{\text{By lookup}}{\implies}$ Some v (good)
  - Subcase: $k<k'$
    - lookup k (insert(k,v) ((k',v'):: t))
    - $\stackrel{\text{By insert}}{\implies}$ lookup k ((k,v)::l)
    - $\stackrel{\text{By lookup}}{\implies}$ Some v (good)
  - Subcase: $k>k'$
    - lookup k (insert(k,v) ((k',v')::t))
    - $\stackrel{\text{By insert}}{\implies}$ lookup k ((k', v')::insert (k,v) t)
    - $\stackrel{\text{By lookup}}{\implies}$ lookup k (insert (k,v) t)
    - $\stackrel{\text{By IH}}{\implies}$ Some $v$
**** Lesson to take away
- State what you are doing induction on
  - Proof by structural induction in the list l
- Consider the different cases!
- For lists, there are two cases- either l =[] or l = h::t
- State your induction hypothesis
  - IH: For all v,k, lookup insert (k,v) t $\Downarrow$ Some $v$
- Justify your evaluation / reasoning steps by
  - Referring to evaluation of a given program
  - The induction hypothesis
  - Lemmas/ Properties (such as associativity, commutativity)
* Lecture 7 <2017-09-26 Tue>
** Structural Induction
- How do I prove that all slices of cake are tasty using structural induction?
  - Define a cake slice recursively
  - Prove that a single piece of cake is tasty
  - Use recursive definition of the set to prove that all slices are tasty
  - Conclude all are tasty
*** Example with rev

#+BEGIN_SRC ocaml
(* naive *)
(* rev: 'a list -> 'a list *)
let rec rev l = match l with
| [] -> []
| x::l -> (rev l) @ [x];;

(* tail recursive *)
(* rev': 'a list -> 'a list *)
let rev' l =
(* rev_tr: 'a list -> 'a list -> 'a list *)
let rec rev_tr l acc = match l with
| [] -> acc
| h::t -> rev_tr t (h::acc)
in
rev_tr 1 [];;

(* Define length *)
let rec length l = match l with
| [] -> 0
| h::t -> 1+length t  
#+END_SRC 
**** Theorem:
For all lists l, rev l = rev' l.

What is the relationship between l, acc and rev_tr l acc?

- Invariant of rev
  - length l = length (rev l)
- Invariant rev_tr
  - length l + length acc = length(rev_tr l acc)
- How are these related?

------
- rev l $\Downarrow$
- rev_tr l acc $\Downarrow$ v
- Not quite because:
  - rev [] $\Downarrow$ []
  - rev_tr [] acc $\Downarrow$ acc
  - Not returning the same thing given empty list
- Slightly modified so it's right:
  - rev l @ acc $\Downarrow$ v
  - rev_tr l acc $\Downarrow$ v

# Let's test it.
# acc = []
----------

For all l, acc, (rev l) @ acc $\Downarrow$ v and rev_tr l acc$\Downarrow$ v
By induction on the list l.
- Case l=[]
  - rev [] @ acc
  - $\stackrel{\text{prog rev}}{\rightarrow}$ [] @ acc $\rightarrow$ acc
  - rev_tr [] acc
  - $\stackrel{\text{by prog rev\_tr}}{\rightarrow}$ acc
- Case $l=h::t$
  - *IH: For all acc rev t @ acc $\Downarrow$ v and rev_tr t acc $\Downarrow$ v*
  - rev (h::t) @ acc $\stackrel{\text{by rev}}{\rightarrow}$ (rev t @ [h])@acc
    - $\stackrel{\text{By associativity of @}}{\rightarrow}$ rev t @ ([h] @ acc)
    - $\stackrel{\text{@}}{\rightarrow}$ rev t @ (h::acc)
  - rev_tr (h::t) acc $\rightarrow$ rev_tr t (h::acc)
  - By the IH rev t @ (h::acc) $\Downarrow$ v and rev_tr t (h::acc) $\Downarrow$ v

# We often simply write:
# For all l, acc, 
# - length(rev_tr) =
** Trees
#+INCLUDE: Test/7.ml src ocaml
* Lecture 8 <2017-09-28 Thu>
** Binary Tree (Inductive definition)
- The empty binary tree empty is a binary tree
- If l and r are binary trees and v is a value of type 'a then Node(v, l, r) is a binary tree
- Nothing else is a binary tree

How to define a recursive data type for trees in OCaml?

#+BEGIN_SRC ocaml
type 'a tree =
Empty
| Node of 'a * 'a tree * 'a tree |
#+END_SRC                              
** Insert
  Want to make a function insert
  - Given as input (x,dx), where x is key and dx is data and a binary search tree t
    - Return a binary search tree with (x,dx) inserted
    - What is insert's type?
      - (a' * b') $\to$ ('a $\times$ 'b)tree $\to$ ('a $\times$ 'b) tree
  - Good exercise: write a function to check if a tree is a binary search tree or not
    - Good exam question

#+INCLUDE: "Test/8.ml" src ocaml

** Proving
- How to reason inductively about trees? Analyze their structures!

** Theorem
For all trees t, keys x, and data dx, lookup x(insert (x, dx) t) $\Rightarrow*$ Some dx
*** Proof by structural induction on the tree t
(You get points on an exam for mentioning what kind of induction, structural induction on tree, points for base case/case, points for stating induction hypothesis, perhaps multiple. Then show by a sequence of steps of how to get from what to show to the end)
- Case t = Empty
  - lookup x (insert (x, dx) Empty) $\stackrel{\text{By insert}}{\Rightarrow}$ lookup x (Node ((x,dx), Empty, Empty)) $\stackrel{\text{by lookup}}{\Rightarrow}$ Some dx
- Case t = Node ( (y,dy), l, r)
  - Both trees l and r are smaller than t
  - IH1: For all x, dx, lookup x (insert (x,dx) l) $\Rightarrow*$ Some dx
  - IH2: For all x, dx, lookup x (insert(x,dx) r) $\Rightarrow*$ Some dx
- Need to show lookup x (insert (x, dx) Node ((y, dy), l, r))
- Show 3 cases (x < y, x = y, y < x)
  - x < y $\Rightarrow$ lookup x (Node((y,dy), insert (x,dx) l, r)) $\stackrel{\text{By lookup}}{\Rightarrow}$ lookup x (insert (x,dx) l) $\stackrel{\text{by IH 1}}{\Rightarrow}$ Some dx
  - x=y lookup x(insert (x,dx) Node ((y, dy), l, r)) $\stackrel{\text{by ins}}{\Rightarrow}$ lookup x (Node ((x,dx), l, r)) $\stackrel{\text{by lookup}}{\Rightarrow}$ Some dx

-------
Exercise: write a type for cake (2 slice of cake together become 1 slice), with weight
* Lecture 9 <2017-09-29 Fri>
** Higher-order functions
- Allows us to abstract over common functionality
- Programs can be very short and compact
- Very reusable, well-structured, modular
- Each significant piece implemented in one place
- Functions are first-class values!
  - Pass functions as arguments (today)
  - Return them as results (next week)
*** Abstracting over common functionality
Want to write a recursive function that sums up over an integer range: $\sum_{k=a}^{k=b}k$

#+BEGIN_SRC ocaml
let rec sum (a,b) =
if a > b then 0 else a + sum(a+1,b)
#+END_SRC

Now what if we want to make a sum of squares? $\sum_{k=a}^{k=b}k^2$

#+BEGIN_SRC ocaml
let rec sum (a,b) =
if a > b then 0 else square(a) + sum(a+1,b)
#+END_SRC

$\sum_{k=a}^{k=b}2^k$

#+BEGIN_SRC ocaml
let rec sum (a,b) =
if a > b then 0 else exp(2,a) + sum(a+1,b)
#+END_SRC

- So you can reimplement the function every time, but it would be more useful to make a sum function that will sum up what you tell it to (what to do to each element)
- Non-Generic Sum (old)
  - int * int -> int
- Generic Sum using a function as an argument
  - (int -> int) -> int * int -> int

** Demo
#+INCLUDE: "Test/9.ml" src ocaml

- How about only summing up odd numbers?

#+BEGIN_SRC ocaml
let rec sumOdd (a,b) =
if (a mod 2) = 1 then 
sum (fun x -> x) (a, b)
else 
sum (fun x -> x)(a+1, b)
#+END_SRC


- Adding increment function
#+BEGIN_SRC ocaml
let rec sum f (a, b) inc =
if (a > b) then 0 else (f a) + sum f (inc(a), b) inc


let rec sumOdd (a,b) =
if (a mod 2) = 1 then 
sum (fun x -> x) (a, b) (fun x -> x+1)
else 
sum (fun x -> x)(a+1, b) (fun x-> x+1)
#+END_SRC

- How about only multiplying?

#+BEGIN_SRC ocaml
let rec product f (a, b) inc =
if (a > b) then 1 else (f a) * product f (inc(a), b) inc
#+END_SRC

- Can make this tail recursive with accumulators for base (1 for prod, 0 for sum)
----------------
- Types: 
  - (int -> int -> int) : comb

  - series: -> (int -> int) : f

  - int * int : a,b lower and upper bound

  - int -> int : inc

  - int : base

Types can get crazy, too much abstraction may lead to less readability
** Bonus
Approximating the integral
- $l = a + dx/2$
  - Use rectangles to approximate
  - Left side of l is above the rectangle, right side is below, approximation should almost cancel them
  - $\int_a^b f(x) dx \approx f(l)*dx + f(l+dx)*dx+f(l+dx+dx)*dx+\ldots =dx * (f(l)+f(l+dx)+f(l+2*dx)+f(l+3*dx) \ldots)$

Want: sum: $\underbrace{(float -> float)}_f -> (\underbrace{float}_l * \underbrace{float}_u) -> \underbrace{(float -> float)}_{inc} -> float$

#+BEGIN_SRC ocaml
let integral f (a,b) dx =
dx * sum f (a+.(dx/2.),b) (fun x-> x+. dx)
(* Follows format of sum function above
Can easily write a short program like above*)
#+END_SRC
* Lecture 10 <2017-10-03 Tue>
#+INCLUDE: "Test/10.ml" src ocaml
* Lecture 11 <2017-10-05 Thu>
** Lambda-Calculus
- Simple language consisting of variables, functions (written as $\lambda x.t$) and function application
- We can define all computable functions in the Lambda-Calculus
- Church Encoding of Booleans:
  - T = $\lambda x.\lambda y.x$ Keeps first argument, throws the other.
  - F = $\lambda x.\lambda y.y$ Keeps second argument, throws the other.
  - Lambda-Calculus is Turing complete, can do everything with it
** Back to the beginning
#+BEGIN_SRC ocaml
(*Binding variables to functions*)
let area : float -> float = function r -> pi *. r *. r
(*or*)
let area (r:float) = pi *. r *. r
#+END_SRC

- The variable name area is bound to the value function r -> pi *. r *. r, which OCaml prints as <fun>
  - The type is float->float
- Good question:
  - let plus x y = x + y
  - What is the type of plus?
    - An integer? (answer 1) Wrong
    - int -> int -> int (answer 2) _Correct answer_
    - A function (answer 3) Wrong, function is not the *type*
  - let plus' (x,y) = x+y
    - type is int * int -> int
- What are types?
  - Base types: Int, float, string...
  - If T is a type and S is a type then
    - T->S is a type
    - T*S is a type
** Curry
let curry $\underbrace{f}_{\text{'a * 'b -> 'c}}= fun \underbrace{x}_{\text{'a}}  \underbrace{y}_{\text{'b}} \text{ -> } f \overbrace{(x, y)}^{\text{'a * b}}_{\text{'a -> 'b -> 'c}}$
- curry $\underbrace{plus'}_{\text{int * int -> int}}$: int -> int -> int
- fun x y -> plus' (x,y)
  - OCaml gives you <fun>
  - Shouldn't we continue evaluation plus'(x,y) and get as a final result fun x y -> x + y?
    - No, we never evaluate inside function bodies
    - When OCaml sees fun, it stops looking
      - It has a function, it's a value, it's done
** Uncurrying
uncurry ('a -> 'b -> 'c) -> 'a * 'b -> 'c
- The type of functions is _right associative_
- *NOT* the same thing as 'a -> 'b -> 'c -> 'a * 'b -> 'c
- *Important* to know how to read functions.
  - Ex. plus function from earlier
  - Can also have plus x = fun y -> x + y
    - int -> (int -> int)
    - Makes a function from an int
** Demo
   We've already seen functions that return other functions: derivatives!
#+INCLUDE: "Test/11.ml" src ocaml
** Partial evaluation
- A technique for optimizing and specializing programs
- Generate programs from other programs
- Produce new programs which run faster than originals and guaranteed to behave in same way
- What is the result of evaluation curry plus'?
  - $\implies$ It's a function!
  - Result: fun x y -> plus' x y
    - Still waiting for x y
    - What if we just pass in 3? (plus 3)
      - fun y -> 3 + y
      - We generated a function!
- let plusSq x y = $\underbrace{x * x}_{horriblyExpensiveThing(x)}$ + y
  - fun y -> 3 * 3 + y (if we set x as 3), won't evaluate this expensive function until we give it a y
  - If we write:
    - plusSq 3 10
    - plusSq 3 15
    - plusSq 3 20
  - We'd have to evaluate horribly expensive function 3 times.
  - Why not store it and use it for the next computation?
#+BEGIN_SRC ocaml
let betterPlusSq x =
	let x = horriblyExpensiveThing(x)
		in fun y -> x + y
#+END_SRC ocaml 
- Now we get:
- let x = horriblyExpensiveThing 3 in fun y -> x+y -> fun y ->9+y
  - Now we can use this function to quickly compute without having to do the expensive function
  - Partial evaluation is very important
* Lecture 12 <2017-10-06 Fri>
- Review by Leila: Today
  - 6-7:30 pm, MC 103
- Cheat sheet correction, minimum 12 pt, not max
** Review
Types of questions:
1. fun x -> x +. 3.3
   - What is the type?
     - float -> float
   - What does it evaluate to?
     - <fun> or fun x -> x +. 3.3
   - let x = 3 in x + 3
     - type: int
     - eval: 6
   - let x = 3 in x +. 3
     - type: error
     - eval: n/a
2. Programming in OCaml
   1) Higher-order functions
      - Nothing too crazy since we haven't had any assignments on it
      - Maybe like the built in functions we implemented the other day
      - using map, for\_all, filter, exists...
3. Induction proof
** Demo, using higher order functions
#+INCLUDE: "Test/12.ml" src ocaml
* Lecture 13 <2017-10-12 Thu>
** Midterm Review
See either 13.ml or Midterm.ml for the questions.
* Lecture 14 <2017-10-13 Fri>
How can we do imperative programming (like C) in a functional language?
- So far, expressions in OCaml have:
  - An expression has a type
  - Expression evaluates to a value (or diverges)
- Today:
  - Expressions in OCaml may also have an effect (one effect is allocating values to memory and updating them)
** Overshadowing
Recall: 
#+BEGIN_SRC ocaml
let (k : int) = 4;;
let (k : int) = 3 in k * k;;
k;; (* This will be 4! *)
#+END_SRC
Binding in line 2 will be gone after line 2.
#+BEGIN_SRC ocaml
let pi = 3.14;;
let area (r:float) = pi *. r *. r;;

let a2 = area (2.0)

let (pi : float) = 6.0;;

let b1 = area (2.0) = a2 (* True *)

let area (r:float) = pi *. r *. r;;
let b2 = area (2.0) = a2 (* False *)
#+END_SRC
For b1, calling area will use the old definition of pi (it already evaluated it when we created the function).
** State
How to program with state? We may want to update memory, for example if we have values that change or an array.
- How to allocate state?
#+BEGIN_SRC ocaml
let x = ref 0
#+END_SRC
Allocates a reference cell with the name x in memory and initializes it with 0. Not the address, cannot do address manipulation.
- How to compare 2 reference cells?
  - Compare their address: ~r == s~
    - Succeeds if both are names for the same location in memory.
  - Compare their content: ~r = s~
#+BEGIN_SRC ocaml
let x = ref 0
let y = ref 0
x = y (*true*)
x==y (*false*)
#+END_SRC
- How to read value stored in a reference cell?
  - ~!x~
  - ~let {contents = x} = r~
    - Pattern match on value that is stored in the reference cell with name x
- How to update value stored?
  - ~x := 3~
** Demo 
#+INCLUDE: "Test/14.ml" src ocaml
- Updating a cell in memory has
  - a value (i.e. unit, written in OCaml as ~()~)
  - an effect (i.e. changes the value in cell x)
- Types
  - ~let r = ref 0~
    - Type of r: int ref
    - ref 0 is an int ref
    - 0 is an int
    - We cannot store a float in r
    - ~!r~ is an int
    - For ~r:=3+2~ to make sense, r should be an int ref and 3+2 must be an int. This returns a type of unit.
* Lecture 15 <2017-10-17 Tue>
** Warm up
Given the following expression write down its type, its value (i.e. what the expression evaluates to), and its effect, if it has any.
- Usually on exams, they should all type check. The error option is just in case they make a typo in typing the question.
- ~3+2~
  - ~int~
  - ~5~
  - No effect
- ~55~
  - ~int~
  - ~55~
  - No effect
- ~fun x -> x+3 *2~
  - ~int -> int~
  - ~<fun>~ or ~fun x -> x + 3 * 2~
- ~((fun x -> match x with [] -> true | y::ys -> false), 3.2 *. 2.0)~
  - ~('a list -> bool) * float~
  - ~(<fun>,6.4)~
  - No effect
- ~let x = ref 3 in x := !x + 2~
  - Example: ~let k=1 in k+2~ is an int, and ~k=1~ gets discarded after ~k+2~ 
  - ~unit~
  - ~()~
  - Effect? No, x is disposed of. Removed from the stack after evaluation in this example. x is now unbound
- ~fun x -> x := 3~
  - ~int ref -> unit~
  - ~<fun>~
  - Effect: updated x to 3
- ~(fun x -> x := 3) y~
  - type: unit
  - value: ()
  - Effect: updated y to 3
- ~fun x -> (x := 3; x)~ (returns x)
  - ~int ref -> int ref~
- ~fun x -> (x := 3; !x)~ (returns !x)
  - ~int ref -> int~
- ~let x = 3 in print_string (string_of_int x)~
  - type: unit
  - value: ()
  - Effect: prints 3 to the screen
** Demo
#+INCLUDE: "Test/15.ml" src ocaml
* Lecture 16 <2017-10-19 Thu>
** Demo
- Mutable Data-Structures
- Closures and Objects
#+INCLUDE: "Test/16.ml" src ocaml
* Lecture 17 <2017-10-20 Fri>
** Exceptions
- Primary benefits:
  - Force you to consider the exceptional case
  - Allows you to segregate the special case from other cases in the code (avoids clutter!)
  - Diverting control flow!
*** Warm-up
- ~3/0~
  - Type: ~int~
  - Value: No value
  - Effect: Raises run-time exception ~Division_by_zero~
#+BEGIN_SRC ocaml
let head_of_empty_list =
    let head (x::t) = x in
	head []
#+END_SRC
- Type: ~'a~
  - head is ~'a list -> 'a~, so it returns ~'a~ in last line
  - Value: No value
  - Effect: raises run-time exception ~Match_failure~
  - Would have been well-defined if we used option return type
*** Demo
1. Signal Error
   - Ex. raise Domain
2. Handle an exception
   - Try <exp> with Domain -> <exp>
#+INCLUDE: "Test/17.ml" src ocaml 
* Lecture 18 <2017-10-24 Tue>
** Backtracking 
- General algorithm for finding all (or some) solutions incrementally - abandons partial candidates as soon as it determines that it cannot lead to a successful solution
- Important tool to solve constraint satisfaction problems such as crosswords, puzzles, Sudoku, etc.
- Ex today:
  - Implement a function ~change~. It takes as input a list of available coins and an amount ~amt~. It returns the exact change for the amount (i.e. a list of available coins, ~[c1;c2;...;cn]~ such that ~c1 + c2 + ... + cn = amt~), if possible; otherwise it raises an exception ~Change~.
~change : int list~ (list of coins) ~-> int~ (amt) ~-> int list~ (list of coins)
- Assumptions:
  - List of coins is ordered
  - Each coin in our list can be used as often as needed
- Good practice/exam question
#+INCLUDE: "Test/18.ml" src ocaml

Backtracking with exceptions:
- Given ~change[6,5,2] 9~
- ~try 6::change[6;5;2] 3 with Change -> change [5;2] 9~
  - ~change [5;2] 3~
    - ~change[2] 3~
    - ~try 2::change[2] 1~ will not work, raise Change and get back to ~change [5;2] 9~ from before
Key thing to take away is:
- You can use exceptions for special cases like dividing by 0
- But a more interesting use is that you can divert control flow
- So you can use it to backtrack and solve problems
* Lecture 19 <2017-10-26 Thu>
** Modules
Primary Benefits:
- Control complexity of developing and maintaining software
- Split large programs into separate pieces
- Name space separation
- Allows for separate compilation
  - Don't always want to recompile the whole project after a small change
  - Incremental compilation & type checking
- Incremental development
- Clear specifications at module boundaries
- Programs are easier to maintain and reuse (!)
- Enforces abstractions
- Isolates bugs
** Signatures (Module Types)
- Declarations can be more specific in the signature than what the module actually implements
- Tying a module to a module type we are hiding information!
  - We can change the module implementation in the future and users won't notice as long as it still implements what we specified in the signature
- Order of signature doesn't have to have the same order as module
** Demo
#+INCLUDE: "Test/19.ml" src ocaml
* Lecture 20 <2017-10-27 Fri>
** More on Modules
- Can hide information when we bind to a module type
- Don't expose how we implement it
- Can even hide what elements we store in the stack
- Nice level of abstraction, so we can easily rip out the implementation and put in a new one
- Makes programs easy to maintain
- Modules are great for enforcing abstraction
** Demo
- Want to implement different currencies
- Bank
- Money
#+INCLUDE: "Test/20.ml" src ocaml
* Lecture 21 <2017-10-31 Tue>
** Continuations
A *continuation* is a representation of the execution state of a program (for example a call stack) at a certain point in time.

Save the current state of execution into some object and restore the state from this object at a later point in time resuming its execution.
*** First-class Support for Continuations
| C#     | async/wait                     |
| Racket | call-with-current-continuation |
| Ruby   | callcc                         |
| Scala  | shift/reset                    |
| Scheme | callcc                         |

Ocaml doesn't have first-class support, so we'll be using functions as continuations! Back to higher order functions.
- Back to the beginning: Recall what tail-recursive means. Can every recursive function be written tail-recursively?
#+BEGIN_SRC ocaml
let rec append l k = match l with
  | [] -> k
  | h::t -> h::append t k
#+END_SRC
- Not tail-recursive, because of ~h::append t k~
- But still efficient
- Can we rewrite it tail-recursively?
*** Recipe
How to re-write a function tail-recursively?
- Add an additional argument, a *continuation*, which acts like an accumulator
- In the base case, we call the continuation
- In the recursive case, we build up the computation that still needs to be done.
A continuation is a stack of functions modeling the call stack, i.e. the work we still need to do upon returning.
- Not always easy to do this, the earlier attempt at tail recursion for append reversed the list.
*** Demo
#+INCLUDE: "Test/21.ml" src ocaml
* Lecture 22 <2017-11-02 Thu>
** Continuation recap
- Building up the stack
- Once you hit base, it collapses
- Seen an example, tail-recursion: the continuation is a functional accumulator; it represents the call stack built when recursively calling a function and builds the final result
- Failure Continuation: the continuation keeps track of what to do upon failure and defers control to the continuation
- Success Continuation: the continuation keeps track of what to do upon success, defers control to the continuation, and builds the final result
*** Demo
#+INCLUDE: "Test/22.ml" src ocaml
* Lecture 23 <2017-11-03 Fri>
** Regular expressions
Going to implement regex with continuations. This is another example of a success continuation.

You might have used them in a Unix shell:
- ~ls *.ml~, list files with suffix ml
- ~ls hw[1-3].ml~, lists hw1.ml, hw2.ml, hw3.ml
Patterns for regular expressions:
- Singleton: Matching a specific character
- Alternation: choice between two patterns
- Concatenation: Succession of patterns
- Iteration: indefinite repetition of patterns
More rigorously: Regular expression $r ::= a | r_1+r_2 | r_1 r_2 | r^* | 0 | 1$
- Backus-Naur-Form
- This is an inductive definition
- How to read this?
- A regex is either: 
  - $a$, a character (anything of type char)
  - $r_1\ r_2$ is concatenation, have both regular expressions
  - $r_1 + r_2$ alternation, can have either
  - $r^*$ iteration, indefinite amount
  - $0$ None
  - $1$ Success
Question: When does a string $s$ match a regular expression $r$?
- If $s$ is in the set of terms described by $r$. (When does this happen?)
*** Examples:
- $a(p^*)l(e+y)$ would match /apple/ or /apply/ or /ale/
- $g(1+r)(e+a)y$, either you succeed (skip it) or find r, /grey/,/gray/,/gay/
- $g(1+o)^*(gle)$, /google/,/gogle/,/goooogle/,/ggle/ (1+o) doesn't matter here, could just be o
- $b(ob0+oba)$, /boba/ but not bob
*** Demo
#+INCLUDE: "Test/23.ml" src ocaml
* Lecture 24 <2017-11-07 Tue>
** Lazy Programming
*** Eager vs Lazy
- Eager Evaluation
  - Evaluate expressions by call-by-value
  - Variables are bound to values
  - Ex. ~let x = 3+2 in x * 2~
    1. Evaluate expression ~3+2~ to the value ~5~
    2. Evaluate expression ~x*2~ in an environment where variable ~x~ is bound to the value ~5~ to the final value ~10~
  - Ex. let x = horribleComp (345) in 5
    1. Evaluate expression horribleComp (345) to some value ~777~
    2. Evaluate expression ~5~ in an environment where variable ~x~ is bound to the value ~777~ to the final value ~5~. Here we bind an expression we don't need.
- Lazy Computation
  - Ex. ~let x = horribleComp (345) in 5~
  - Bind variables to unevaluated expressions (not values!)
  - Suspend computation ~horribleComp (345)~ until needed
  - Memoize results because:
    - ~let x = horribleComp (345) in x + x~ will recompute horribleComp twice
  - Lazy usually doesn't go well with state, which is why most imperative languages are eager
  - Harder to reason about but very useful for:
    - Infinite data (ex. representing all prime numbers, reading part of a file instead of the whole thing)
    - Interactive data (ex. sequence or stream of inputs)
*** Finite vs Infinite
- Finite Data
  - ~type 'a list = Nil | Cons of 'a * 'a list~
    - Encodes an inductive definition of finite lists
    - ~Nil~ is a list of type ~'a list~
    - If ~x~ is of type ~'a~ and ~xs~ is a list of type ~'a list~ then ~cons(x,xs)~ is a list of type ~'a list~
    - Nothing else is a list
  - How do we take apart lists? By pattern matching.
  - How do we reason with lists? By induction on the structure of lists
- Infinite Data
  - Instead of saying how to construct infinite data, we define it by the observations we make about them
  - Given a stream ~1,2,3,4,5,...~ we can ask:
    - The head of the stream: ~1~
    - The tail of the stream: ~2, 3, 4, 5, ...~
  - Can we always make an observation? Does this terminate eventually? No, does not terminate.
    - Observations should be productive, shouldn't go into infinite loops. We can make an observation at each step.
*** Suspending
How to suspend and prevent evaluation of an expression?
#+BEGIN_SRC ocaml
    type 'a susp = Susp of unit -> 'a

    (* Force evaluation of suspended computation *)
    let force (Susp f) = f ()

  (* Example of suspending and forcing computation *)
  let x = Susp (fun () -> horribleComp(345)) in force x + force x
#+END_SRC
Wrap your function in lazy programming so that it suspends computation
- Infinite Streams: ~type 'a str = {hd : 'a ; tl : ('a str) susp}~
  - Encodes a coinductive definition of infinite streams using the two observations ~hd~ and ~tl~
    - Asking for the head using the observation ~hd~ returns element of type ~'a~
    - Asking for the tail using the observation ~tl~ returns a suspended stream of type ~('a str) susp~
    - If you want more elements you need to ask for more
    - Very demand driven
** DEMO
#+INCLUDE: "Test/24.ml" src ocaml
* Lecture 25 <2017-11-09 Thu>
** Demo
#+INCLUDE: "Test/25.ml" src ocaml
*** Sieve of Eratosthenes:
Generate a stream of prime numbers
- Start with natural numbers starting at 2
- $2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \ldots$
- First number, $2$ is a hit.
- Now look at tail and filter out all even numbers.
  - Now you have a stream of odd numbers.
- Head this time is $3$. Now remove all things that are multiples of $3$
* Lecture 26 <2017-11-10 Fri>
** Fundamental Principles in Programming Language Design
Three key questions:
- What are the syntactically legal expression? What expressions does the parser accept?
  - Grammar
- What are well-typed expressions? What expressions does the type-checker accept?
  - Static semantics
- How is an expression executed?
  - Dynamic semantics
  - Why isn't a program working? Seems logically correct, but then how do we delve further?
Definitely need to know the answers to all 3 questions if you're writing a compiler or your own language.
*** Syntactically Legal Expressions
Def. (Not the definition for Ocaml, but similar and essentially for a basic language)

The set of expressions is defined inductively by the following clauses
1. A number $n$ is an expression
2. The booleans ~true~ and ~false~ are expressions.
3. If $e_1$ and $e_2$ are expressions, then $e_1$ op $e_2$ is an expression where $op =\{+,=,-,*,<\}$
4. If $e$, $e_1$ and $e_2$ are expressions, then ~if~ $e$ then $e_1$ ~else~ $e_2$ is an expression
Example of legal expressions:
- ~if 3 then 2+3 else 5~
  - This is syntactically fine, but it's a type error
When we define languages, we typically have 3 stages: 
1. source -> lexer -> parser (syntax errors here)
   - After parse, you have an abstract syntax tree
   - How do I read ~3+2=7~? ~(3+2)=7~ or ~3+(2=7)~?
   - The definition above is tree like (with the if statements)
   - We won't talk much about parsing and lexing, as most of that has been solved
2. -> type checker (if it exists, also type errors are here) -> interpreter & evaluation (run-time errors/run time exceptions)
*** Backus-Naur Form (BNF)
Alternative to the previous definition.

Operations op ::= $+|-|*|<|=$

Expressions $e$ ::= $n|e_1 \ op \ e_2 | true | false | if \ e \ then \ e_1 \ else \ e_2$

**** Representation in OCaml
#+BEGIN_SRC ocaml
type primop = Equals | LessThan | Plus | Minus | Times

type exp = 
| Int of int (* 0 | 1 | 2 | ... *)
| Bool of bool (* true | false *)
| If of exp * exp * exp (* if e then e_1 else e_2 *)
| Primop of primop * exp list (*e_1 primop e_2 or primop e *)
#+END_SRC
Example: 
- ~if 3<0 then 1 else 0~ is represented as ~If (Primop (LessThan, [Int 3 ; Int 0]), Int 1, Int 0)~
- ~if true then 3~ cannot be represented, no else
*** Evaluation
How to evaluate an expression?
- How to describe evaluation of expressions?
- We want to say: "Expression $e$ evaluates to a value $v$"
- What are values?
  - Values $v$ ::= $n | true | false$
Definition

Evaluation of the expression $e$ to a value $v$ is defined inductively by the following clauses:
- A value $v$ evaluates to itself.
- If expression $e$ evaluates to the value ~true~ and expression $e_1$ evaluates to a value $v$, then ~if~ $e$ ~then~ $e_1$ ~else~ $e_2$ evaluates to the value $v$.
- If expression $e$ evaluates to the value ~false~ and expression $e_2$ evaluates to a value $v$, then ~if~ $e$ ~then~ $e_1$ ~else~ $e_2$ evaluates to the value $v$.
Too verbose and doesn't even talk about primitive operators. Need more compact notation.

$e \Downarrow v$ for "Expression $e$ evaluates to value $v$"

Definition with new notation:

$e \Downarrow v$ is defined inductively by the following clauses:
- $v \Downarrow v$
- If $e \Downarrow$ ~true~ and $e_1 \Downarrow v$, then ~if~ $e$ ~then~ $e_1$ ~else~ $e_2 \Downarrow v$
- If $e \Downarrow$ ~false~ and $e_2 \Downarrow v$, then ~if~ $e$ ~then~ $e_1$ ~else~ $e_2 \Downarrow v$

Turning informal description into a formal one
$$\frac{premise_1 \ \ldots \ premise_n}{conclusion}\text{name}$$
Read as: If $premise_1$ and $premise_2$ and $\ldots premise_n$, then conclusion.

$$\frac{}{v \Downarrow v}\text{B-VAL}$$
$$\frac{e \Downarrow true \ e_1 \Downarrow v}{if \ e \ then \ e_1 \ else \ e_2 \Downarrow v}\text{B-IFTRUE}$$
$$\frac{e \Downarrow false \ e_2 \Downarrow v}{if \ e \ then \ e_1 \ else \ e_2 \Downarrow v}\text{B-IFFALSE}$$
Here we only talk about the good things, ~true~ or ~false~. We don't define what would happen if $e \Downarrow$ something else, like a number. Then we would raise not defined.
* Lecture 27 <2017-11-14 Tue>
** Designing our own language
(Continuation from last class)

We transformed evaluation into a formal description with premises and a conclusion. Note that evaluation rules do not impose an order on the premises. This works if we don't have state.

Extending further:
- If $e_1 \Downarrow v_1$ and $e_2 \Downarrow v_2$, then $e_1 \ op \ e_2 \Downarrow v$ where $v = \overline{v_1 \ op \ v_2}$
- $\frac{e_1 \Downarrow v_1 \ e_2 \Downarrow v_2}{e_1 \ op \ e_2 \Downarrow \overline{v_1 \ op \ v_2}}$ B-OP
How to use these rules?
- Example in slides

Our operational semantics ($e \Downarrow v$) is what we formalized.

Task: Implement a function ~eval~ that does what $e \Downarrow v$ describes.
#+BEGIN_SRC ocaml
let rec eval e = match e with
| Int _ -> e
| Bool _ -> e
| If (e, e1, e2) ->
    (match eval e with
    | Bool true -> eval e1
    | Bool false -> eval e2
    | _ -> raise (Stuck "guard is not  bool"))
#+END_SRC
*** Why do we care about a formal description?
- More compact
Establish properties and formal guarantees
- Coverage: For all expressions ~e~ there exists an evaluation rule.
- Determinacy: If $e \Downarrow v_1$ and $e \Downarrow v_2$ then $v_1=v_2$
- Value Soundness: If $e \Downarrow v$ then $v$ is a value.
  - Should always return a value
*** Advantages of an implementation
We can run it!
*** Static Type Checking
- Types approximate runtime behavior
- Lightweight tool for reasoning about programs
- Detect errors statically, early in the development cycle
- Great for code maintenance
- Precise error messages
- Checkable documentation of code
How do we make types work?
- Types classify expressions according to the kinds of values they compute
  - What are values though?
    - Values v ::= n | true | false
  - Hence, there are only two basic types.
    - Types T ::= int | bool
    - In OCaml -> ints, floats, functions, unit, ref, etc.
**** Types
e:T, expression $e$ has type $T$

Def:
1. n : int
2. true : bool and false : bool
3. If e : bool and $e_1:T$ and $e_2:T$, then if $e$ then $e_1$ else $e_2$ : $T$
4. If $e_1$ : int and $e_2$ : int, then $e_1 + e_2$ : int
5. If $e_1 : T$ and $e_2 : T$, then $e_1 = e_2$ : bool
Can be converted to premises
- $\frac{}{true:bool}$ T-T
- $\frac{}{false:bool}$ T-F
- $\frac{e_1:T \ e_2:T}{e_1 = e_2 : bool}$ T-EQ
- $\frac{}{n:int}$ T-NUM
- $\frac{e_1:int \ e_2:int}{e_1+e_2:int}$ T-PLUS
- $\frac{e:bool \ e_1:T \ e_2:T}{if \ e \ then \ e_1 \ else \ e_2:T}$ T-IF

Two readings of typing
- Type Checking $e:T$
  - Given the expression $e$ and the type $T$, we check that $e$ does have type $T$
- Type Inference $e:T$
  - Given the expression $e$, we infer its type $T$
- OCaml does both and well
- Checking is difficult for us with T-EQ, we don't know what type $T$ is.
** Demo
#+INCLUDE: "Test/27.ml" src ocaml
* Lecture 28 <2017-11-16 Thu>
Extending our language with variables, let-expressions, and functions!
- Add the following expressions: $x | let \ x = e_1 \ in \ e_2 \ end$
Are the following well-formed?
- ~let x = x in x + 1 end~
  - x is not defined, not well-formed
- ~let x = y in x + 1 end~
  - Same problem, y is not defined.
  - Is this equal to the line above? What kind of renaming do we want?
- ~let x = 1 in let y = x end in x + y end~
  - Legal
- ~let x = 1 in let x = x + 2 end in x + x end~
  - Legal, important to know where things are bound, the first x bounds the $x$ in $x+2$. The second let x statement bounds the $x$ in $x+x$
** Free Variables
Variable names should not matter

These are all the same: 
- ~let x = 5 in (let y = x + 3 in y + y end) end~
- ~let x = 5 in (let x = x + 3 in x + x end) end~
- ~let v = 5 in (let w = v + 3 in w + w end) end~

Defining Free Variables:
- $FV(e)$ returns the set of the free variable names occurring in the expression ~e~.
  - It is defined inductively based on the structure of the expression ~e~.
- $FV(e_1 \ op \ e_2) = FV(e_1) \cup FV(e_2)$
- $FV(n) = \{ \ \}$
- $FV(x) = \{x\}$
- $FV(let \ x = e_1 \ in \ e_2)$
- $FV(e_1) \cup FV(e_1) \setminus \{x\}$
  - ~let x = 1 in let y = x+1 end in x+y end~
    - First look at ~x+y~ -> x and y are free
    - Now looking at ~let y = x + 1~, ~x~ is free here.
    - Apply the function to this let expression, get that ~x~ is free
      - $\{x\} \cup \{x,y\}\setminus \{y\}$
    - Then look at the outer ~let x~. Nothing free there.
    - Apply the function again, get $\{\} \cup \{x\} \setminus \{x\}$
- $FV(if \ e \ then \ e_1 \ else \ e_2) = FV(e) \cup FV(e_1) \cup FV(e_2)$
In OCaml, ~let~, functions and pattern matching bound variables. In programming languages, no variables should be free, not bound.
** Substitution
Define as: ~[e'/x]e~ Replace all *free* occurrences of the variable ~x~ in the expression ~e~ with expression ~e'~

Can be read as a function:
- Input: Expression ~e'~, variable ~x~, and expression ~e~
- Output: an expression where all *free* occurrences of the variable ~x~ in expression ~e~ have been replaced by ~e'~
Substitution is defined by considering different cases for ~e~.
* Lecture 29 <2017-11-17 Fri>
Continuation from last class.
** Substitution
- Example: ~e = if x = 1 then y + 2 else x + y~
  - ~[w*2/x]e = if (w * 2) = 1 then y + 2 else (w*2) + y~
How to define this function? Let's look at different cases.
- ~[e'/x] (n) = n~
- ~[e'/x] (x) = e'~
- ~[e'/x] (y) = y~ (where $x \neq y$)
- *Incorrect definition:* ~[e'/x]~ ~(let y =~ $e_1$ ~in~ $e_2$ ~end) = let y = [e'/x]~ $e_1$ in ~[e'/x]~ $e_2$ ~end~
  - Ex: ~[5/x](let y = x + 1 in x + y end) = let y = 5 + 1 in 5 + y end~
  - But what about: ~[5/x] (let x = x + 1 in x + y end) = let x = 5 + 1 in x + y end~
    - The first ~x~ is now bound
    - Check $y\neq x$
    - Rename _x_
    - ~[5/x] (let x1 = x + 1 in x1 + y end) = let x1 = 5 + 1 in x1 + y end~
  - What about: ~[y*5/x](let x = (y * 5) + 1 in x + y end) = let y = (y * 5) + 1 in (y * 5) + y end~
    - But the ~y~ we substituted in was free, but it is now bound
    - Should check if the free expression we're substitution in is captured by some other expression inside
    - $y \notin FV(e')$
    - _Capture avoidance_
#+INCLUDE: "Test/29.ml" src ocaml
** Free variables
- $FV(e_1 e_2) = FV(e_1) \cup FV(e_2)$
- $FV(fun \ x = e) = FV(3) \setminus \{x\}$
- $FV([e'/x] (fun y = e))$
  - Need to check 2 conditions for substitution for free vars: $x \neq y$ and $y \notin FV(e')$
** Important concepts of the past few lectures
Variables, understanding what the scope is, understanding free variables, how to substitute variables into different expressions (and avoiding issues like capture avoidance), replacing calls via substitution
* Lecture 30 <2017-11-21 Tue>
How to describe well-typed expressions?
- How can we statically check whether an expression would potentially lead to a runtime error?
  - Conservative, won't find all errors, but will find some
  - Lightweight
  - Gives precise error messages
  - Check-able documentation in code
We can write many non-sensical expressions. The following should be ill-typed:
- ~if 3 then 4 else 2~
  - ~3~ is not a boolean here
- ~if true then 2 else false~
  - ~2~ and ~false~ are not the same time
- ~true*false-1~
  - We don't allow multiplication of booleans in our language
- ~let y = x in y + 1 end~
  - This could be considered ill-typed
  - But in many languages this is considered ill-scoped (~x~ is unbound)
- ~let x = true in let y = 3 in y + y end end~
  - Well-typed
- ~let y = true in let y = 3 in y + y end end~
  - Well-typed? Why? The second let statement overshadows the previous ~y~. The ~y + y~ refers to the inner ~y~
** Typing in context
Reconsider: $e: T$
- The expression ~let x = e_1 in e_2 end~ has type $S$ if
  1. $e_1$ has type $T$
  2. Assuming $x$ has type $T$, show that $e_2$ has type $S$.
     - ex. y has type int, y+1 returns int given an int y
Generally: 
- Given assumptions $\underbrace{x_1 : T_1 , \ldots , x_n : T_n}_{\text{Typing Context }\Gamma}$, $e$ has type $T$
- In our language we're going to restrict every variable to appearing at most once in our context assumptions
- Don't necessarily have to use assumptions
- Can use assumptions multiple times, like in ~y + y~
- Useful to think of assumptions as resources -> this is linear logic

When do we collect use assumptions?
- When you encounter the variable itself. Variable $x$ has type $T$ in a typing context $\Gamma$ if there exists a declaration $x:T$ in $\Gamma$
When do we collect assumptions?
- ~let x = e_1 in e_2 end end~ has type $T$ in a typing context $\Gamma$, if
  - expression $e_1$ has type $T_1$ in the context $\Gamma$
  - expression $e_2$ has type $T$ in the extended context $\Gamma, x : T_1$

Does this type-check?
#+BEGIN_SRC 
let y = true in
    if true then (let y=3 in y+3 end)
    else (if y then 1 else 2)

#+END_SRC
This is well typed, we are not replacing $y$, just having a newer local version
- Think of this as a stack, will use newer values first. When we get to else, ~y~ is still a bool.
* Lecture 31 <2017-11-23 Thu>
** T-FN rule
Get the type of a function given the typing context and the type $T_1$ of x (the argument) which implies the type of the returning expression
- Can't use this yet, don't know where $T_1$ is coming from
- How to deal with this? Make $T_1$ an unknown type
*** Type variables
- Add a new type, $\alpha$
Examples of type checking and inference with this new type
- ~fun x -> x :~ $\alpha$ ~->~ $\alpha$
  + $\alpha$ here is the most general type
  + We can get ~int -> int~ from it by [int/$\alpha$] ($\alpha$ ~->~ $\alpha$)
  + ~bool -> bool~ = [bool/$\alpha$] ($\alpha$ ~->~ $\alpha$)
  + ~(char * bool) -> (char~ $\times$ ~bool) =~ [char $\times$ bool/$\alpha$] $\alpha$ ~->~ $\alpha$
  + No matter what we chose for $\alpha$, this is still well typed
- Type of ~fn f~ $\implies$ ~fn x -> f(x)~?
  - i.e. ~(fn f -> fn x -> f x) (fn y -> y + 1) 2~ returns ~3~
  - ($\alpha$ -> $\beta$) -> $\alpha$ -> $\beta$
  - Does there exist an instantiation for the type variables s.t. it becomes well typed?
    - Yes [$\alpha/\beta$]
  - Instantiation for identity?
    - Yes [$\alpha$ -> $\alpha/\beta$]
- Instantiation for $\alpha$ ~-> int~? Yes, [int/$\alpha$]
- There are polymorphic types & functions in OCaml, like List.map. Doesn't care what type $\alpha$ and $\beta$ are, it will work on any
** T-APP rule
** Type Inference
We want to infer types.

Damas-Hindley-Milner Style Type Inference

# Given typing context $\Gamma$ and an expression $e$, infer a type $T$ (and some constraints) as follows:
# - Analyze $e$ as before following the given typing rules
# - When we analyze $e$ recursively and e is type information, introduce a type variable and generate possible constraints
# - Te type $T$ is a skeleton that may contain type variables
# - To determine whether $e$ is well-typed, solve the constraints!
# - Solving constraints
- Infer type of if expression ~if x then 3 else 2 + 2~
  - Infer type of ~x~. Apply guard, constraint is checking if condition is a boolean, constraint $\alpha=$ ~bool~
  - Infer type of y as $\beta$
  - Infer type of ~2+2~ as ~int~
  - Gives you constraint $\beta=$ ~int~
- Another ex. Infer the type of ~fn f -> fn x -> f x :~
  - We end up with $\alpha$ -> $\beta$ -> $\gamma$, with the constraint ($\alpha = \beta$ -> $\gamma$). Therefore, ($\beta$ -> $\gamma$) -> $\beta$ -> $\gamma$
- ~fn x => x+1~ has type $\alpha$ ~-> int/~ {$\alpha =$ ~int~}
- ~fn x => if x then x+1 else 2~, does not type check. You get \ldots/{$\alpha =$ bool, $\alpha=$ int}. Clashes
- ~fn f => fn x => f (f x)~ type $\alpha$ -> $\beta$ -> $\alpha_1$ with {$\alpha = \beta$ -> $\alpha_0$, $\alpha = \alpha_0$ -> $\alpha_1$}
